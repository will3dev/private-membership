pragma solidity ^0.8.0;

import { AppendMerkleTree } from "./merkleTrees/AppendMerkleTree.sol";
import { MerkleProof, PointsBalance, NewMembershipProof, EGCT, Point, MembershipProof } from "./types/EncryptedMembershipTypes.sol";
import { IEncryptedLoyaltyPoints } from "./interfaces/IEncryptedLoyaltyPoints.sol";
import { INewMembershipVerifier } from "./interfaces/verifiers/INewMembershipVerifier.sol";
import { IMembershipVerifier } from "./interfaces/verifiers/IMembershipVerifier.sol";
import { BabyJubJub } from "./libraries/BabyJubJub.sol";

contract EncryptedMembership is AppendMerkleTree {

    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The address of the encrypted loyalty points contract
    IEncryptedLoyaltyPoints public encryptedLoyaltyPoints;

    /// @notice The addresses of the verifiers for ZKPs
    INewMembershipVerifier public newMembershipVerifier; 
    IMembershipVerifier public membershipVerifier;

    ///////////////////////////////////////////////////
    ///                   Events                    ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when a new member is successfully registered with the protocol
     * @param membershipHash the keccak256 hash of the poseidon2 hash from the membership proof
     * @param membershipPoseidonHash the poseidon hash extracted from the membership proof 
     * @param publicKey the derived public key of the user that was added to the membership tree
    */
    event newMemberAdded (
        bytes32 membershipHash,
        uint256 membershipPoseidonHash,
        uint256[2] publicKey
    );
    
    ///////////////////////////////////////////////////
    ///                   Errors                    ///
    ///////////////////////////////////////////////////

    error invalidMerkleProof();
    error invalidAddress();
    error loyaltyPointsAlreadySet();
    error invalidProof();
    error invalidHash();
    
    // TOO: update to use interfaces for verifiers
    constructor(address _newMembershipVerifier, address _membershipVerifier) {
        newMembershipVerifier = INewMembershipVerifier(_newMembershipVerifier);
        membershipVerifier = IMembershipVerifier(_membershipVerifier);
        _initializeMerkleTree();
    }

    function setEncryptedLoyaltyPoints(address _encryptedLoyaltyPoints) public {
        if (_encryptedLoyaltyPoints == address(0)) {
            revert invalidAddress();
        }

        if (encryptedLoyaltyPoints != IEncryptedLoyaltyPoints(address(0))) {
            revert loyaltyPointsAlreadySet();
        }

        encryptedLoyaltyPoints = IEncryptedLoyaltyPoints(_encryptedLoyaltyPoints);
    }

    /**
     * @dev This function is used to become a member of the encrypted membership.
     * @param newMembershipProof the proof required to be generated by the user to become a member.
     */
    function becomeMember(NewMembershipProof calldata newMembershipProof) public {
        // validate the newMembershipProof
        uint256[3] memory publicSignals = newMembershipProof.publicSignals;
        
        // extract the leaf
        uint256 membershipHash = publicSignals[2];

        // extract the public key from the proof
        uint256[2] memory bjjPubKey = [
            publicSignals[0], 
            publicSignals[1]
        ];

        // Hash should be less than the BN254 scalar field size
        if ( membershipHash >= BabyJubJub.Q) {
            revert invalidHash();
        }
        
        // transform the integer to a 
        bytes32 transformedMembershipHash = keccak256(abi.encodePacked(membershipHash)); // TODO: update to use poseidon hash instead of keccak
        
        // validate the newMembershipProof
        bool isVerified = newMembershipVerifier.verifyProof(
            newMembershipProof.proofPoints.a,
            newMembershipProof.proofPoints.b,
            newMembershipProof.proofPoints.c,
            newMembershipProof.publicSignals
        );

        if (!isVerified) {
            revert invalidProof();
        }

        // TO DO extract starter values for membership

        /*
        // extract the EGCT value
        // TODO: update for correct values
        EGCT memory startingPointsEGCT = EGCT({
            c1: Point({x: publicSignals[0], y: publicSignals[1]}),
            c2: Point({x: publicSignals[2], y: publicSignals[3]})
        });

        // extract the PCT of the balance
        uint256[7] memory startingPointsPCT;
        for (uint256 i = 0; i < 7; i++) {
            startingPointsPCT[i] = publicSignals[i + 4]; // TODO: update the number to be starting point of PCT
        }
        */

               // emit the event indicating that a new membership was successfully added
        emit newMemberAdded(transformedMembershipHash, membershipHash, bjjPubKey);


        // add the leaf to the merkle tree
        _addLeaf(transformedMembershipHash);


        
    }

    /**
     * @dev This function is used to prove membership of a leaf in the merkle tree.
     * @param membershipProof The membership proof to validate. This is a ZKP that a user must pass showing that they are able to properly form the leaf hash.
     * @param merkleProof The merkle proof to validate.
     * @return isMember a boolean value indicating if the provided user is a member.
     * This function would be used to act as a gatecheck when validating a user. It would be used as a helper function for external operations such as claiming points.
     */
    function proveMembership(MembershipProof calldata membershipProof, MerkleProof calldata merkleProof) public view returns (bool isMember) {
        // validate teh membershipProof
        bool isValidMerkleProof = _validateProof(merkleProof.leafPosition, merkleProof.merkleProof, merkleProof.merkleRoot);
        
        if (!isValidMerkleProof) {
            revert invalidMerkleProof();
        }

        // validate the membershipProof
        bool isVerified = newMembershipVerifier.verifyProof(
            membershipProof.proofPoints.a,
            membershipProof.proofPoints.b,
            membershipProof.proofPoints.c,
            membershipProof.publicSignals
        );

        if (!isVerified) {
            revert invalidProof();
        }

        return true;
    }

    /**
     * @dev This function is used to get all the membership commitments for the merkle tree.
     * @return membershipCommitments The membership commitments for the merkle tree. These are all of the leaves of the membership tree.
     */
    function getAllMembershipCommitments() public view returns (bytes32[] memory membershipCommitments) {
        return _getLeaves();
    }

   /**
    * @dev This function is used to check if a leaf is a member of the merkle tree.
    * @param leaf The leaf to check if it is a member of the merkle tree.
    * @return isValid a boolean value indicating if the provided user is a member.
    */
    function isValidMembership(bytes32 leaf) public view returns (bool isValid) {
        return leafLookup[leaf];
    }

    /**
     * @dev This function is used to get the number of membership commitments for the merkle tree.
     * @return membershipCount The number of membership commitments for the merkle tree.
     */
    function getMembershipCount() public view returns (uint256 membershipCount) {
        return _getLeafCount();
    }



    


}